TODO:
- controllare una per una tutte le syscall

- Ogni volta che un processo si blocca (-> viene chiamato lo scheduler), bisogna aggiornare il CPU (3.8)


- trovare un filo logico e sequenziale migliore (il ritorno dopo un'eccezione, che sia SYS o interrupt, è troppo incasinata)


LEGGETE PRIMA DI COMINCIARE A FARE DEBUG:
1. ho cambiato qualche while con dei for perchè altrimenti dava problemi
2. condizione dell'interrupt nei terminali VA RIVISTA, entra quando non dovrebbe
3. c'è la parte commentata negli interrupt perchè ho cambiato il deviceSem e non avevo sbatti di cambiarlo ovunque
4. Ho inserito la macro per la disabilitazione dell'interrupt ma TEORICAMENTE dovrebbe farlo da solo (con l'invio di ACK)
5. ORA rimane loopato, bisogna capire il motivo

P.S. Problemi quando si accede al dato referenziato e lo si incrementa con ++;

Da fare quando funge tutto:
- creare un file unico con tutte le utilities comune a tutti i file, ovvero:
    - tutti i file extern
    - tutti gli include
    - funzioni ausiliare (P/V/findDevice ecc...)
- divisione .h e .c
- eliminare, se ancora ci sono, numeri assoluti (meglio inserirli come #define)


//////////// 27_04_2023 ////////////////

1) P e V devono bloccare il processo current sulla coda anche nel
caso in cui ci sia la risorsa disponibile ma la coda del semaforo 
non vuota

2) Quando un processo esegue una systemcall non bloccante, si fa carico del tempo in cui e' stato dentro l'handler, dato che
alla prossima gettime viene calcolato il tempo di inizio e quello di fine senza tenere contro di quello in cui si e' stoppato.

3) c'e' un problema di rimozioni di processi, counter dei ready negativo !!


