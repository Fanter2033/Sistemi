TODO:
- controllare una per una tutte le syscall

- Ogni volta che un processo si blocca (-> viene chiamato lo scheduler), bisogna aggiornare il CPU (3.8)

- trovare un filo logico e sequenziale migliore (il ritorno dopo un'eccezione, che sia SYS o interrupt, è troppo incasinata)


LEGGETE PRIMA DI COMINCIARE A FARE DEBUG:
1. ho cambiato qualche while con dei for perchè altrimenti dava problemi
2. condizione dell'interrupt nei terminali VA RIVISTA, entra quando non dovrebbe
3. c'è la parte commentata negli interrupt perchè ho cambiato il deviceSem e non avevo sbatti di cambiarlo ovunque
4. Ho inserito la macro per la disabilitazione dell'interrupt ma TEORICAMENTE dovrebbe farlo da solo (con l'invio di ACK)
5. ORA rimane loopato, bisogna capire il motivo

P.S. Problemi quando si accede al dato referenziato e lo si incrementa con ++;

Da fare quando funge tutto:
- creare un file unico con tutte le utilities comune a tutti i file, ovvero:
    - tutti i file extern
    - tutti gli include
    - funzioni ausiliare (P/V/findDevice ecc...)
- divisione .h e .c
- eliminare, se ancora ci sono, numeri assoluti (meglio inserirli come #define)


//////////// 27_04_2023 ////////////////

1) P e V devono bloccare il processo current sulla coda anche nel
caso in cui ci sia la risorsa disponibile ma la coda del semaforo 
non vuota

2) Quando un processo esegue una systemcall non bloccante, si fa carico del tempo in cui e' stato dentro l'handler, dato che
alla prossima gettime viene calcolato il tempo di inizio e quello di fine senza tenere contro di quello in cui si e' stoppato.

Punto in cui si blocca:
quando in p2 avviene il for con tutte le Verhogen e le Passeren, arriva al decimo semaforo( indirizzo: 0x2000.9408 ) e, durante la Verhogen,
entra nel ramo headBlocked != NULL (semaforo non viene MAI usato prima porco zio pera)


////////////// 05_05_2023 ////////////////

1) risolvere il problema nel print (angelo ha aggiunto un campo nel pcb per ritornare il valore dello status dopo l'esecuzione di doio)

2) aggiustare il tempo

3) rifare la find device

Aggiustare questo e poi si va avanti nel test

Problema attuale:
In p6 c'è scritto che il processo dovrebbe terminare chiamando la syscall 1 ma in realtà continua e va a printare 
Inoltre ci dovrebbe essere anche un altro problema perchè non è quel panic() (anche se comunque ci entrerebbe)
per Debug: p6+0x38

p6 -> entra DOIO nella print -> si ferma sul semaforo del terminal -> schedule -> LDST -> kernel panic


///////////// 08_05_2023 ////////////////
Problema del print risolto

1) Aggiustare il tempo!!

2) rifare find device (per riattivare tutti i dispositivi)

3) controllare la Terminate!! (importante per continuare a testare in quanto ci sono processi che dovranno uccidere anche figli).
    problemi che ha adesso:
    - scheduler chiamato nella funzione (NON ha senso essendo ricorsivo!!!)
    - controllo sui semafori da cambiare
    - controllare le funzioni ausiliare in pcb.h 

Problema attuale:
non so il motivo ma si ferma dopo la clockwait nel p5b 
(p5b clockwait -> mi blocco -> scheduler prende un processo-> PANIC)
NON è il panic dello scheduler.